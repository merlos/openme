---
title: "Server Setup"
---

## Install {#install}

### From a pre-built binary

Download the latest release from [GitHub Releases](https://github.com/openme/openme/releases):

```bash
# Linux amd64
curl -Lo openme https://github.com/openme/openme/releases/latest/download/openme-linux-amd64
chmod +x openme
sudo mv openme /usr/local/bin/
```

### Build from source

Requires [Go 1.21+](https://go.dev/dl/).

```bash
git clone https://github.com/openme/openme
cd openme/cli
go build -o openme ./cmd/openme
sudo mv openme /usr/local/bin/
```

---

## Initialise the Server

`openme init` generates a fresh Curve25519 keypair and writes
`/etc/openme/config.yaml` with sensible defaults.

```bash
sudo openme init --server myserver.example.com
```

Options:

| Flag | Default | Description |
|------|---------|-------------|
| `--server` | *(required)* | Public hostname or IP — used in generated client configs |
| `--port` | `7777` | UDP knock port and TCP health port |
| `--firewall` | `nft` | Firewall backend: `nft` or `iptables` |
| `--force` | `false` | Overwrite an existing config |

The command prints the server's **Curve25519 public key** — you'll need this
when provisioning clients, but `openme add` handles it automatically.

---

## Open the Knock Port

The UDP knock port must be reachable (the point is that TCP ports are not):

```bash
# nftables
sudo nft add rule inet filter input udp dport 7777 accept

# iptables
sudo iptables -A INPUT -p udp --dport 7777 -j ACCEPT
```

::: {.callout-tip}
For IPv6, add an equivalent `ip6tables` or `nft inet` rule.
:::

---

## Start the Server

```bash
sudo openme serve
```

For production, install as a systemd service:

```ini
# /etc/systemd/system/openme.service
[Unit]
Description=openme SPA server
After=network.target

[Service]
ExecStart=/usr/local/bin/openme serve
Restart=on-failure
AmbientCapabilities=CAP_NET_ADMIN

[Install]
WantedBy=multi-user.target
```

```bash
sudo systemctl enable --now openme
sudo systemctl status openme
```

---

## Verify

Once a client is configured and has knocked, you can verify the full round trip:

```bash
# Knock and immediately check the health port (end-to-end test)
openme status --knock

# Check health port only (requires a prior knock within knock_timeout)
openme status
```

::: {.callout-note}
The health port is **never permanently open**. It is opened by the firewall
only after a valid knock, for the `knock_timeout` duration (default 30s).
A closed health port means either no knock has been sent yet, or the
`knock_timeout` has expired.
:::

Next: [Add a client →](adding-clients.qmd)
